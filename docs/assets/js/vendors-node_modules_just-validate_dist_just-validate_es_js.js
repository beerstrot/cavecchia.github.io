"use strict";
(self["webpackChunkfoundation_zurb_template"] = self["webpackChunkfoundation_zurb_template"] || []).push([["vendors-node_modules_just-validate_dist_just-validate_es_js"],{

/***/ "./node_modules/just-validate/dist/just-validate.es.js":
/*!*************************************************************!*\
  !*** ./node_modules/just-validate/dist/just-validate.es.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CustomStyleTagIds": function() { return /* binding */ CustomStyleTagIds; },
/* harmony export */   "GroupRules": function() { return /* binding */ GroupRules; },
/* harmony export */   "Rules": function() { return /* binding */ Rules; },
/* harmony export */   "default": function() { return /* binding */ JustValidate; }
/* harmony export */ });
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }
var __defProp = Object.defineProperty;
var __defNormalProp = function __defNormalProp(obj, key, value) {
  return key in obj ? __defProp(obj, key, {
    enumerable: true,
    configurable: true,
    writable: true,
    value: value
  }) : obj[key] = value;
};
var __publicField = function __publicField(obj, key, value) {
  __defNormalProp(obj, _typeof(key) !== "symbol" ? key + "" : key, value);
  return value;
};
var EMAIL_REGEXP = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var INTEGER_REGEXP = /^-?[0-9]\d*$/;
var PASSWORD_REGEXP = /^(?=.*[A-Za-z])(?=.*\d).{8,}$/;
var STRONG_PASSWORD_REGEXP = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
var isEmpty = function isEmpty(value) {
  var newVal = value;
  if (typeof value === "string") {
    newVal = value.trim();
  }
  return !newVal;
};
var isEmail = function isEmail(value) {
  return EMAIL_REGEXP.test(value);
};
var isLengthMoreThanMax = function isLengthMoreThanMax(value, len) {
  return value.length > len;
};
var isLengthLessThanMin = function isLengthLessThanMin(value, len) {
  return value.length < len;
};
var isNumber = function isNumber(value) {
  if (typeof value !== "string") {
    return false;
  }
  return !isNaN(+value) && !isNaN(parseFloat(value));
};
var isInteger = function isInteger(value) {
  return INTEGER_REGEXP.test(value);
};
var isPassword = function isPassword(value) {
  return PASSWORD_REGEXP.test(value);
};
var isStrongPassword = function isStrongPassword(value) {
  return STRONG_PASSWORD_REGEXP.test(value);
};
var isNumberMoreThanMax = function isNumberMoreThanMax(value, len) {
  return value > len;
};
var isNumberLessThanMin = function isNumberLessThanMin(value, len) {
  return value < len;
};
var isInvalidOrEmptyString = function isInvalidOrEmptyString(value) {
  return typeof value !== "string" || value === "";
};
var Rules = /* @__PURE__ */function (Rules2) {
  Rules2["Required"] = "required";
  Rules2["Email"] = "email";
  Rules2["MinLength"] = "minLength";
  Rules2["MaxLength"] = "maxLength";
  Rules2["Password"] = "password";
  Rules2["Number"] = "number";
  Rules2["Integer"] = "integer";
  Rules2["MaxNumber"] = "maxNumber";
  Rules2["MinNumber"] = "minNumber";
  Rules2["StrongPassword"] = "strongPassword";
  Rules2["CustomRegexp"] = "customRegexp";
  Rules2["MinFilesCount"] = "minFilesCount";
  Rules2["MaxFilesCount"] = "maxFilesCount";
  Rules2["Files"] = "files";
  return Rules2;
}(Rules || {});
var GroupRules = /* @__PURE__ */function (GroupRules2) {
  GroupRules2["Required"] = "required";
  return GroupRules2;
}(GroupRules || {});
var CustomStyleTagIds = /* @__PURE__ */function (CustomStyleTagIds2) {
  CustomStyleTagIds2["Label"] = "label";
  CustomStyleTagIds2["LabelArrow"] = "labelArrow";
  return CustomStyleTagIds2;
}(CustomStyleTagIds || {});
var defaultDictionary = [{
  key: Rules.Required,
  dict: {
    en: "The field is required"
  }
}, {
  key: Rules.Email,
  dict: {
    en: "Email has invalid format"
  }
}, {
  key: Rules.MaxLength,
  dict: {
    en: "The field must contain a maximum of :value characters"
  }
}, {
  key: Rules.MinLength,
  dict: {
    en: "The field must contain a minimum of :value characters"
  }
}, {
  key: Rules.Password,
  dict: {
    en: "Password must contain minimum eight characters, at least one letter and one number"
  }
}, {
  key: Rules.StrongPassword,
  dict: {
    en: "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character"
  }
}, {
  key: Rules.Number,
  dict: {
    en: "Value should be a number"
  }
}, {
  key: Rules.MaxNumber,
  dict: {
    en: "Number should be less or equal than :value"
  }
}, {
  key: Rules.MinNumber,
  dict: {
    en: "Number should be more or equal than :value"
  }
}, {
  key: Rules.MinFilesCount,
  dict: {
    en: "Files count should be more or equal than :value"
  }
}, {
  key: Rules.MaxFilesCount,
  dict: {
    en: "Files count should be less or equal than :value"
  }
}, {
  key: Rules.Files,
  dict: {
    en: "Uploaded files have one or several invalid properties (extension/size/type etc)."
  }
}];
var DEFAULT_ERROR_FIELD_MESSAGE = "Value is incorrect";
var isPromise = function isPromise(val) {
  return _typeof(val) === "object" && val !== null && "then" in val && typeof val.then === "function";
};
var getNodeParents = function getNodeParents(el) {
  var elem = el;
  var els = [];
  while (elem) {
    els.unshift(elem);
    elem = elem.parentNode;
  }
  return els;
};
var getClosestParent = function getClosestParent(groups, parents) {
  var reversedParents = _toConsumableArray(parents).reverse();
  for (var i = 0, len = reversedParents.length; i < len; ++i) {
    var parent = reversedParents[i];
    for (var key in groups) {
      var group = groups[key];
      if (group.groupElem === parent) {
        return [key, group];
      }
    }
  }
  return null;
};
var getClassList = function getClassList(classList) {
  if (Array.isArray(classList)) {
    return classList.filter(function (cls) {
      return cls.length > 0;
    });
  }
  if (typeof classList === "string" && classList.trim()) {
    return _toConsumableArray(classList.split(" ").filter(function (cls) {
      return cls.length > 0;
    }));
  }
  return [];
};
var isElement = function isElement(element) {
  return element instanceof Element || element instanceof HTMLDocument;
};
var errorLabelCss = ".just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}";
var TOOLTIP_ARROW_HEIGHT = 5;
var defaultGlobalConfig = {
  errorFieldStyle: {
    color: "#b81111",
    border: "1px solid #B81111"
  },
  errorFieldCssClass: "just-validate-error-field",
  successFieldCssClass: "just-validate-success-field",
  errorLabelStyle: {
    color: "#b81111"
  },
  errorLabelCssClass: "just-validate-error-label",
  successLabelCssClass: "just-validate-success-label",
  focusInvalidField: true,
  lockForm: true,
  testingMode: false,
  validateBeforeSubmitting: false
};
var JustValidate = /*#__PURE__*/function () {
  function JustValidate(form, globalConfig, dictLocale) {
    var _this = this;
    _classCallCheck(this, JustValidate);
    __publicField(this, "form", null);
    __publicField(this, "fields", {});
    __publicField(this, "groupFields", {});
    __publicField(this, "errors", {});
    __publicField(this, "isValid", false);
    __publicField(this, "isSubmitted", false);
    __publicField(this, "globalConfig", defaultGlobalConfig);
    __publicField(this, "errorLabels", {});
    __publicField(this, "successLabels", {});
    __publicField(this, "eventListeners", []);
    __publicField(this, "dictLocale", defaultDictionary);
    __publicField(this, "currentLocale", "en");
    __publicField(this, "customStyleTags", {});
    __publicField(this, "onSuccessCallback");
    __publicField(this, "onFailCallback");
    __publicField(this, "onValidateCallback");
    __publicField(this, "tooltips", []);
    __publicField(this, "lastScrollPosition");
    __publicField(this, "isScrollTick");
    __publicField(this, "fieldIds", /* @__PURE__ */new Map());
    __publicField(this, "getKeyByFieldSelector", function (field) {
      return _this.fieldIds.get(field);
    });
    __publicField(this, "getFieldSelectorByKey", function (key) {
      var _iterator = _createForOfIteratorHelper(_this.fieldIds),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
            fieldSelector = _step$value[0],
            k = _step$value[1];
          if (key === k) {
            return fieldSelector;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      return void 0;
    });
    __publicField(this, "getCompatibleFields", function () {
      var fields = {};
      Object.keys(_this.fields).forEach(function (key) {
        var newKey = key;
        var fieldSelector = _this.getFieldSelectorByKey(key);
        if (typeof fieldSelector === "string") {
          newKey = fieldSelector;
        }
        fields[newKey] = _objectSpread({}, _this.fields[key]);
      });
      return fields;
    });
    __publicField(this, "setKeyByFieldSelector", function (field) {
      if (_this.fieldIds.has(field)) {
        return _this.fieldIds.get(field);
      }
      var key = String(_this.fieldIds.size + 1);
      _this.fieldIds.set(field, key);
      return key;
    });
    __publicField(this, "refreshAllTooltips", function () {
      _this.tooltips.forEach(function (item) {
        item.refresh();
      });
    });
    __publicField(this, "handleDocumentScroll", function () {
      _this.lastScrollPosition = window.scrollY;
      if (!_this.isScrollTick) {
        window.requestAnimationFrame(function () {
          _this.refreshAllTooltips();
          _this.isScrollTick = false;
        });
        _this.isScrollTick = true;
      }
    });
    __publicField(this, "formSubmitHandler", function (ev) {
      ev.preventDefault();
      _this.isSubmitted = true;
      _this.validateHandler(ev);
    });
    __publicField(this, "handleFieldChange", function (target) {
      var foundKey;
      for (var key in _this.fields) {
        var field = _this.fields[key];
        if (field.elem === target) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      _this.fields[foundKey].touched = true;
      _this.validateField(foundKey, true);
    });
    __publicField(this, "handleGroupChange", function (target) {
      var foundKey;
      for (var key in _this.groupFields) {
        var group = _this.groupFields[key];
        if (group.elems.find(function (elem) {
          return elem === target;
        })) {
          foundKey = key;
          break;
        }
      }
      if (!foundKey) {
        return;
      }
      _this.groupFields[foundKey].touched = true;
      _this.validateGroup(foundKey, true);
    });
    __publicField(this, "handlerChange", function (ev) {
      if (!ev.target) {
        return;
      }
      _this.handleFieldChange(ev.target);
      _this.handleGroupChange(ev.target);
      _this.renderErrors();
    });
    this.initialize(form, globalConfig, dictLocale);
  }
  _createClass(JustValidate, [{
    key: "initialize",
    value: function initialize(form, globalConfig, dictLocale) {
      this.form = null;
      this.errors = {};
      this.isValid = false;
      this.isSubmitted = false;
      this.globalConfig = defaultGlobalConfig;
      this.errorLabels = {};
      this.successLabels = {};
      this.eventListeners = [];
      this.customStyleTags = {};
      this.tooltips = [];
      this.currentLocale = "en";
      if (typeof form === "string") {
        var elem = document.querySelector(form);
        if (!elem) {
          throw Error("Form with ".concat(form, " selector not found! Please check the form selector"));
        }
        this.setForm(elem);
      } else if (form instanceof HTMLFormElement) {
        this.setForm(form);
      } else {
        throw Error("Form selector is not valid. Please specify a string selector or a DOM element.");
      }
      this.globalConfig = _objectSpread(_objectSpread({}, defaultGlobalConfig), globalConfig);
      if (dictLocale) {
        this.dictLocale = [].concat(_toConsumableArray(dictLocale), defaultDictionary);
      }
      if (this.isTooltip()) {
        var styleTag = document.createElement("style");
        styleTag.textContent = errorLabelCss;
        this.customStyleTags[CustomStyleTagIds.Label] = document.head.appendChild(styleTag);
        this.addListener("scroll", document, this.handleDocumentScroll);
      }
    }
  }, {
    key: "getLocalisedString",
    value: function getLocalisedString(rule, ruleValue, customMsg) {
      var _a;
      var search = customMsg != null ? customMsg : rule;
      var localisedStr = (_a = this.dictLocale.find(function (item) {
        return item.key === search;
      })) == null ? void 0 : _a.dict[this.currentLocale];
      if (!localisedStr) {
        if (customMsg) {
          localisedStr = customMsg;
        }
      }
      if (localisedStr && ruleValue !== void 0) {
        switch (rule) {
          case Rules.MaxLength:
          case Rules.MinLength:
          case Rules.MaxNumber:
          case Rules.MinNumber:
          case Rules.MinFilesCount:
          case Rules.MaxFilesCount:
            localisedStr = localisedStr.replace(":value", String(ruleValue));
        }
      }
      return localisedStr || customMsg || DEFAULT_ERROR_FIELD_MESSAGE;
    }
  }, {
    key: "getFieldErrorMessage",
    value: function getFieldErrorMessage(fieldRule, elem) {
      var msg = typeof fieldRule.errorMessage === "function" ? fieldRule.errorMessage(this.getElemValue(elem), this.fields) : fieldRule.errorMessage;
      return this.getLocalisedString(fieldRule.rule, fieldRule.value, msg);
    }
  }, {
    key: "getFieldSuccessMessage",
    value: function getFieldSuccessMessage(successMessage, elem) {
      var msg = typeof successMessage === "function" ? successMessage(this.getElemValue(elem), this.fields) : successMessage;
      return this.getLocalisedString(void 0, void 0, msg);
    }
  }, {
    key: "getGroupErrorMessage",
    value: function getGroupErrorMessage(groupRule) {
      return this.getLocalisedString(groupRule.rule, void 0, groupRule.errorMessage);
    }
  }, {
    key: "getGroupSuccessMessage",
    value: function getGroupSuccessMessage(groupRule) {
      if (!groupRule.successMessage) {
        return void 0;
      }
      return this.getLocalisedString(void 0, void 0, groupRule.successMessage);
    }
  }, {
    key: "setFieldInvalid",
    value: function setFieldInvalid(key, fieldRule) {
      this.fields[key].isValid = false;
      this.fields[key].errorMessage = this.getFieldErrorMessage(fieldRule, this.fields[key].elem);
    }
  }, {
    key: "setFieldValid",
    value: function setFieldValid(key, successMessage) {
      this.fields[key].isValid = true;
      if (successMessage !== void 0) {
        this.fields[key].successMessage = this.getFieldSuccessMessage(successMessage, this.fields[key].elem);
      }
    }
  }, {
    key: "setGroupInvalid",
    value: function setGroupInvalid(key, groupRule) {
      this.groupFields[key].isValid = false;
      this.groupFields[key].errorMessage = this.getGroupErrorMessage(groupRule);
    }
  }, {
    key: "setGroupValid",
    value: function setGroupValid(key, groupRule) {
      this.groupFields[key].isValid = true;
      this.groupFields[key].successMessage = this.getGroupSuccessMessage(groupRule);
    }
  }, {
    key: "getElemValue",
    value: function getElemValue(elem) {
      switch (elem.type) {
        case "checkbox":
          return elem.checked;
        case "file":
          return elem.files;
        default:
          return elem.value;
      }
    }
  }, {
    key: "validateGroupRule",
    value: function validateGroupRule(key, elems, groupRule) {
      switch (groupRule.rule) {
        case GroupRules.Required:
          {
            if (elems.every(function (elem) {
              return !elem.checked;
            })) {
              this.setGroupInvalid(key, groupRule);
            } else {
              this.setGroupValid(key, groupRule);
            }
          }
      }
    }
  }, {
    key: "validateFieldRule",
    value: function validateFieldRule(key, elem, fieldRule) {
      var _this2 = this;
      var afterInputChanged = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var ruleValue = fieldRule.value;
      var elemValue = this.getElemValue(elem);
      if (fieldRule.plugin) {
        var result = fieldRule.plugin(elemValue, this.getCompatibleFields());
        if (!result) {
          this.setFieldInvalid(key, fieldRule);
        }
        return;
      }
      switch (fieldRule.rule) {
        case Rules.Required:
          {
            if (isEmpty(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.Email:
          {
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (!isEmail(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.MaxLength:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (isLengthMoreThanMax(elemValue, ruleValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.MinLength:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (isLengthLessThanMin(elemValue, ruleValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.Password:
          {
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (!isPassword(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.StrongPassword:
          {
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (!isStrongPassword(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.Number:
          {
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (!isNumber(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.Integer:
          {
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            if (!isInteger(elemValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.MaxNumber:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            var num = +elemValue;
            if (Number.isNaN(num) || isNumberMoreThanMax(num, ruleValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.MinNumber:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (isInvalidOrEmptyString(elemValue)) {
              break;
            }
            var _num = +elemValue;
            if (Number.isNaN(_num) || isNumberLessThanMin(_num, ruleValue)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.CustomRegexp:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            var regexp;
            try {
              regexp = new RegExp(ruleValue);
            } catch (e) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] should be a valid regexp. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            var str = String(elemValue);
            if (str !== "" && !regexp.test(str)) {
              this.setFieldInvalid(key, fieldRule);
            }
            break;
          }
        case Rules.MinFilesCount:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length < ruleValue) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            break;
          }
        case Rules.MaxFilesCount:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (typeof ruleValue !== "number") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be a number. The field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            if (Number.isFinite(elemValue == null ? void 0 : elemValue.length) && elemValue.length > ruleValue) {
              this.setFieldInvalid(key, fieldRule);
              break;
            }
            break;
          }
        case Rules.Files:
          {
            if (ruleValue === void 0) {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field is not defined. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            if (_typeof(ruleValue) !== "object") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be an object. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            var filesConfig = ruleValue.files;
            if (_typeof(filesConfig) !== "object") {
              console.error("Value for ".concat(fieldRule.rule, " rule for [").concat(key, "] field should be an object with files array. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            var isFilePropsInvalid = function isFilePropsInvalid(file, fileConfig) {
              var minSizeInvalid = Number.isFinite(fileConfig.minSize) && file.size < fileConfig.minSize;
              var maxSizeInvalid = Number.isFinite(fileConfig.maxSize) && file.size > fileConfig.maxSize;
              var nameInvalid = Array.isArray(fileConfig.names) && !fileConfig.names.includes(file.name);
              var extInvalid = Array.isArray(fileConfig.extensions) && !fileConfig.extensions.includes(file.name.split(".")[file.name.split(".").length - 1]);
              var typeInvalid = Array.isArray(fileConfig.types) && !fileConfig.types.includes(file.type);
              return minSizeInvalid || maxSizeInvalid || nameInvalid || extInvalid || typeInvalid;
            };
            if (_typeof(elemValue) === "object" && elemValue !== null) {
              for (var fileIdx = 0, len = elemValue.length; fileIdx < len; ++fileIdx) {
                var file = elemValue.item(fileIdx);
                if (!file) {
                  this.setFieldInvalid(key, fieldRule);
                  break;
                }
                var filesInvalid = isFilePropsInvalid(file, filesConfig);
                if (filesInvalid) {
                  this.setFieldInvalid(key, fieldRule);
                  break;
                }
              }
            }
            break;
          }
        default:
          {
            if (typeof fieldRule.validator !== "function") {
              console.error("Validator for custom rule for [".concat(key, "] field should be a function. This field will be always invalid."));
              this.setFieldInvalid(key, fieldRule);
              return;
            }
            var _result = fieldRule.validator(elemValue, this.getCompatibleFields());
            if (typeof _result !== "boolean" && typeof _result !== "function") {
              console.error("Validator return value for [".concat(key, "] field should be boolean or function. It will be cast to boolean."));
            }
            if (typeof _result === "function") {
              if (afterInputChanged) {
                this.fields[key].asyncCheckPending = true;
              } else {
                this.fields[key].asyncCheckPending = false;
                var promise = _result();
                if (!isPromise(promise)) {
                  console.error("Validator function for custom rule for [".concat(key, "] field should return a Promise. This field will be always invalid."));
                  this.setFieldInvalid(key, fieldRule);
                  return;
                }
                return promise.then(function (resp) {
                  if (!resp) {
                    _this2.setFieldInvalid(key, fieldRule);
                  }
                }).catch(function () {
                  _this2.setFieldInvalid(key, fieldRule);
                });
              }
            }
            if (!_result) {
              this.setFieldInvalid(key, fieldRule);
            }
          }
      }
    }
  }, {
    key: "isFormValid",
    value: function isFormValid() {
      var isValid = true;
      for (var i = 0, len = Object.values(this.fields).length; i < len; ++i) {
        var item = Object.values(this.fields)[i];
        if (item.isValid === void 0) {
          isValid = void 0;
          break;
        }
        if (item.isValid === false) {
          isValid = false;
          break;
        }
      }
      for (var _i2 = 0, _len = Object.values(this.groupFields).length; _i2 < _len; ++_i2) {
        var _item = Object.values(this.groupFields)[_i2];
        if (_item.isValid === void 0) {
          isValid = void 0;
          break;
        }
        if (_item.isValid === false) {
          isValid = false;
          break;
        }
      }
      return isValid;
    }
  }, {
    key: "validateField",
    value: function validateField(key) {
      var _this3 = this;
      var afterInputChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _a;
      var field = this.fields[key];
      field.isValid = true;
      var promises = [];
      _toConsumableArray(field.rules).reverse().forEach(function (rule) {
        var res = _this3.validateFieldRule(key, field.elem, rule, afterInputChanged);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      if (field.isValid) {
        this.setFieldValid(key, (_a = field.config) == null ? void 0 : _a.successMessage);
      }
      return Promise.allSettled(promises).finally(function () {
        var _a2;
        if (afterInputChanged) {
          (_a2 = _this3.onValidateCallback) == null ? void 0 : _a2.call(_this3, {
            isValid: _this3.isFormValid(),
            isSubmitted: _this3.isSubmitted,
            fields: _this3.getCompatibleFields(),
            groups: _objectSpread({}, _this3.groupFields)
          });
        }
      });
    }
  }, {
    key: "revalidateField",
    value: function revalidateField(fieldSelector) {
      var _this4 = this;
      if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
        throw Error("Field selector is not valid. Please specify a string selector or a valid DOM element.");
      }
      var key = this.getKeyByFieldSelector(fieldSelector);
      if (!key || !this.fields[key]) {
        console.error("Field not found. Check the field selector.");
        return Promise.reject();
      }
      return new Promise(function (resolve) {
        _this4.validateField(key, true).finally(function () {
          _this4.clearFieldStyle(key);
          _this4.clearFieldLabel(key);
          _this4.renderFieldError(key, true);
          resolve(!!_this4.fields[key].isValid);
        });
      });
    }
  }, {
    key: "revalidateGroup",
    value: function revalidateGroup(groupSelector) {
      var _this5 = this;
      if (typeof groupSelector !== "string" && !isElement(groupSelector)) {
        throw Error("Group selector is not valid. Please specify a string selector or a valid DOM element.");
      }
      var key = this.getKeyByFieldSelector(groupSelector);
      if (!key || !this.groupFields[key]) {
        console.error("Group not found. Check the group selector.");
        return Promise.reject();
      }
      return new Promise(function (resolve) {
        _this5.validateGroup(key).finally(function () {
          _this5.clearFieldLabel(key);
          _this5.renderGroupError(key, true);
          resolve(!!_this5.groupFields[key].isValid);
        });
      });
    }
  }, {
    key: "validateGroup",
    value: function validateGroup(key) {
      var _this6 = this;
      var afterInputChanged = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var group = this.groupFields[key];
      var promises = [];
      _toConsumableArray(group.rules).reverse().forEach(function (rule) {
        var res = _this6.validateGroupRule(key, group.elems, rule);
        if (isPromise(res)) {
          promises.push(res);
        }
      });
      return Promise.allSettled(promises).finally(function () {
        var _a;
        if (afterInputChanged) {
          (_a = _this6.onValidateCallback) == null ? void 0 : _a.call(_this6, {
            isValid: _this6.isFormValid(),
            isSubmitted: _this6.isSubmitted,
            fields: _this6.getCompatibleFields(),
            groups: _objectSpread({}, _this6.groupFields)
          });
        }
      });
    }
  }, {
    key: "focusInvalidField",
    value: function focusInvalidField() {
      var _this7 = this;
      var _loop = function _loop() {
        var field = _this7.fields[key];
        if (!field.isValid) {
          setTimeout(function () {
            return field.elem.focus();
          }, 0);
          return "break";
        }
      };
      for (var key in this.fields) {
        var _ret = _loop();
        if (_ret === "break") break;
      }
    }
  }, {
    key: "afterSubmitValidation",
    value: function afterSubmitValidation() {
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.renderErrors(forceRevalidation);
      if (this.globalConfig.focusInvalidField) {
        this.focusInvalidField();
      }
    }
  }, {
    key: "validate",
    value: function validate() {
      var _this8 = this;
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new Promise(function (resolve) {
        var promises = [];
        Object.keys(_this8.fields).forEach(function (key) {
          var promise = _this8.validateField(key);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        Object.keys(_this8.groupFields).forEach(function (key) {
          var promise = _this8.validateGroup(key);
          if (isPromise(promise)) {
            promises.push(promise);
          }
        });
        Promise.allSettled(promises).then(function () {
          var _a;
          _this8.afterSubmitValidation(forceRevalidation);
          (_a = _this8.onValidateCallback) == null ? void 0 : _a.call(_this8, {
            isValid: _this8.isFormValid(),
            isSubmitted: _this8.isSubmitted,
            fields: _this8.getCompatibleFields(),
            groups: _objectSpread({}, _this8.groupFields)
          });
          resolve(!!promises.length);
        });
      });
    }
  }, {
    key: "revalidate",
    value: function revalidate() {
      var _this9 = this;
      return new Promise(function (resolve) {
        _this9.validateHandler(void 0, true).finally(function () {
          if (_this9.globalConfig.focusInvalidField) {
            _this9.focusInvalidField();
          }
          resolve(_this9.isValid);
        });
      });
    }
  }, {
    key: "validateHandler",
    value: function validateHandler(ev) {
      var _this10 = this;
      var forceRevalidation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (this.globalConfig.lockForm) {
        this.lockForm();
      }
      return this.validate(forceRevalidation).finally(function () {
        var _a, _b;
        if (_this10.globalConfig.lockForm) {
          _this10.unlockForm();
        }
        if (_this10.isValid) {
          (_a = _this10.onSuccessCallback) == null ? void 0 : _a.call(_this10, ev);
        } else {
          (_b = _this10.onFailCallback) == null ? void 0 : _b.call(_this10, _this10.getCompatibleFields(), _this10.groupFields);
        }
      });
    }
  }, {
    key: "setForm",
    value: function setForm(form) {
      this.form = form;
      this.form.setAttribute("novalidate", "novalidate");
      this.removeListener("submit", this.form, this.formSubmitHandler);
      this.addListener("submit", this.form, this.formSubmitHandler);
    }
  }, {
    key: "addListener",
    value: function addListener(type, elem, handler) {
      elem.addEventListener(type, handler);
      this.eventListeners.push({
        type: type,
        elem: elem,
        func: handler
      });
    }
  }, {
    key: "removeListener",
    value: function removeListener(type, elem, handler) {
      elem.removeEventListener(type, handler);
      this.eventListeners = this.eventListeners.filter(function (item) {
        return item.type !== type || item.elem !== elem;
      });
    }
  }, {
    key: "addField",
    value: function addField(fieldSelector, rules, config) {
      if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
        throw Error("Field selector is not valid. Please specify a string selector or a valid DOM element.");
      }
      var elem;
      if (typeof fieldSelector === "string") {
        elem = this.form.querySelector(fieldSelector);
      } else {
        elem = fieldSelector;
      }
      if (!elem) {
        throw Error("Field doesn't exist in the DOM! Please check the field selector.");
      }
      if (!Array.isArray(rules) || !rules.length) {
        throw Error("Rules argument should be an array and should contain at least 1 element.");
      }
      rules.forEach(function (item) {
        if (!("rule" in item || "validator" in item || "plugin" in item)) {
          throw Error("Rules argument must contain at least one rule or validator property.");
        }
        if (!item.validator && !item.plugin && (!item.rule || !Object.values(Rules).includes(item.rule))) {
          throw Error("Rule should be one of these types: ".concat(Object.values(Rules).join(", "), ". Provided value: ").concat(item.rule));
        }
      });
      var key = this.setKeyByFieldSelector(fieldSelector);
      this.fields[key] = {
        elem: elem,
        rules: rules,
        isValid: void 0,
        touched: false,
        config: config
      };
      this.setListeners(elem);
      if (this.isSubmitted || this.globalConfig.validateBeforeSubmitting) {
        this.validateField(key);
      }
      return this;
    }
  }, {
    key: "removeField",
    value: function removeField(fieldSelector) {
      if (typeof fieldSelector !== "string" && !isElement(fieldSelector)) {
        throw Error("Field selector is not valid. Please specify a string selector or a valid DOM element.");
      }
      var key = this.getKeyByFieldSelector(fieldSelector);
      if (!key || !this.fields[key]) {
        console.error("Field not found. Check the field selector.");
        return this;
      }
      var type = this.getListenerType(this.fields[key].elem.type);
      this.removeListener(type, this.fields[key].elem, this.handlerChange);
      this.clearErrors();
      delete this.fields[key];
      return this;
    }
  }, {
    key: "removeGroup",
    value: function removeGroup(group) {
      var _this11 = this;
      if (typeof group !== "string") {
        throw Error("Group selector is not valid. Please specify a string selector.");
      }
      var key = this.getKeyByFieldSelector(group);
      if (!key || !this.groupFields[key]) {
        console.error("Group not found. Check the group selector.");
        return this;
      }
      this.groupFields[key].elems.forEach(function (elem) {
        var type = _this11.getListenerType(elem.type);
        _this11.removeListener(type, elem, _this11.handlerChange);
      });
      this.clearErrors();
      delete this.groupFields[key];
      return this;
    }
  }, {
    key: "addRequiredGroup",
    value: function addRequiredGroup(groupField, errorMessage, config, successMessage) {
      var _this12 = this;
      if (typeof groupField !== "string" && !isElement(groupField)) {
        throw Error("Group selector is not valid. Please specify a string selector or a valid DOM element.");
      }
      var elem;
      if (typeof groupField === "string") {
        elem = this.form.querySelector(groupField);
      } else {
        elem = groupField;
      }
      if (!elem) {
        throw Error("Group selector not found! Please check the group selector.");
      }
      var inputs = elem.querySelectorAll("input");
      var childrenInputs = Array.from(inputs).filter(function (input) {
        var parent = getClosestParent(_this12.groupFields, getNodeParents(input));
        if (!parent) {
          return true;
        }
        return parent[1].elems.find(function (elem2) {
          return elem2 !== input;
        });
      });
      var key = this.setKeyByFieldSelector(groupField);
      this.groupFields[key] = {
        rules: [{
          rule: GroupRules.Required,
          errorMessage: errorMessage,
          successMessage: successMessage
        }],
        groupElem: elem,
        elems: childrenInputs,
        touched: false,
        isValid: void 0,
        config: config
      };
      inputs.forEach(function (input) {
        _this12.setListeners(input);
      });
      return this;
    }
  }, {
    key: "getListenerType",
    value: function getListenerType(type) {
      switch (type) {
        case "checkbox":
        case "select-one":
        case "file":
        case "radio":
          {
            return "change";
          }
        default:
          {
            return "input";
          }
      }
    }
  }, {
    key: "setListeners",
    value: function setListeners(elem) {
      var type = this.getListenerType(elem.type);
      this.removeListener(type, elem, this.handlerChange);
      this.addListener(type, elem, this.handlerChange);
    }
  }, {
    key: "clearFieldLabel",
    value: function clearFieldLabel(key) {
      var _a, _b;
      (_a = this.errorLabels[key]) == null ? void 0 : _a.remove();
      (_b = this.successLabels[key]) == null ? void 0 : _b.remove();
    }
  }, {
    key: "clearFieldStyle",
    value: function clearFieldStyle(key) {
      var _field$elem$classList;
      var _a, _b, _c, _d;
      var field = this.fields[key];
      var errorStyle = ((_a = field.config) == null ? void 0 : _a.errorFieldStyle) || this.globalConfig.errorFieldStyle;
      Object.keys(errorStyle).forEach(function (key2) {
        field.elem.style[key2] = "";
      });
      var successStyle = ((_b = field.config) == null ? void 0 : _b.successFieldStyle) || this.globalConfig.successFieldStyle || {};
      Object.keys(successStyle).forEach(function (key2) {
        field.elem.style[key2] = "";
      });
      (_field$elem$classList = field.elem.classList).remove.apply(_field$elem$classList, _toConsumableArray(getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass)).concat(_toConsumableArray(getClassList(((_d = field.config) == null ? void 0 : _d.successFieldCssClass) || this.globalConfig.successFieldCssClass))));
    }
  }, {
    key: "clearErrors",
    value: function clearErrors() {
      var _this13 = this;
      var _a, _b;
      Object.keys(this.errorLabels).forEach(function (key) {
        return _this13.errorLabels[key].remove();
      });
      Object.keys(this.successLabels).forEach(function (key) {
        return _this13.successLabels[key].remove();
      });
      for (var key in this.fields) {
        this.clearFieldStyle(key);
      }
      var _loop2 = function _loop2() {
        var group = _this13.groupFields[_key];
        var errorStyle = ((_a = group.config) == null ? void 0 : _a.errorFieldStyle) || _this13.globalConfig.errorFieldStyle;
        Object.keys(errorStyle).forEach(function (key2) {
          group.elems.forEach(function (elem) {
            var _elem$classList;
            var _a2;
            elem.style[key2] = "";
            (_elem$classList = elem.classList).remove.apply(_elem$classList, _toConsumableArray(getClassList(((_a2 = group.config) == null ? void 0 : _a2.errorFieldCssClass) || _this13.globalConfig.errorFieldCssClass)));
          });
        });
        var successStyle = ((_b = group.config) == null ? void 0 : _b.successFieldStyle) || _this13.globalConfig.successFieldStyle || {};
        Object.keys(successStyle).forEach(function (key2) {
          group.elems.forEach(function (elem) {
            var _elem$classList2;
            var _a2;
            elem.style[key2] = "";
            (_elem$classList2 = elem.classList).remove.apply(_elem$classList2, _toConsumableArray(getClassList(((_a2 = group.config) == null ? void 0 : _a2.successFieldCssClass) || _this13.globalConfig.successFieldCssClass)));
          });
        });
      };
      for (var _key in this.groupFields) {
        _loop2();
      }
      this.tooltips = [];
    }
  }, {
    key: "isTooltip",
    value: function isTooltip() {
      return !!this.globalConfig.tooltip;
    }
  }, {
    key: "lockForm",
    value: function lockForm() {
      var elems = this.form.querySelectorAll("input, textarea, button, select");
      for (var i = 0, len = elems.length; i < len; ++i) {
        elems[i].setAttribute("data-just-validate-fallback-disabled", elems[i].disabled ? "true" : "false");
        elems[i].setAttribute("disabled", "disabled");
        elems[i].style.pointerEvents = "none";
        elems[i].style.webkitFilter = "grayscale(100%)";
        elems[i].style.filter = "grayscale(100%)";
      }
    }
  }, {
    key: "unlockForm",
    value: function unlockForm() {
      var elems = this.form.querySelectorAll("input, textarea, button, select");
      for (var i = 0, len = elems.length; i < len; ++i) {
        if (elems[i].getAttribute("data-just-validate-fallback-disabled") !== "true") {
          elems[i].removeAttribute("disabled");
        }
        elems[i].style.pointerEvents = "";
        elems[i].style.webkitFilter = "";
        elems[i].style.filter = "";
      }
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip(elem, errorLabel, position) {
      var _this14 = this;
      var _a;
      var _elem$getBoundingClie = elem.getBoundingClientRect(),
        top = _elem$getBoundingClie.top,
        left = _elem$getBoundingClie.left,
        width = _elem$getBoundingClie.width,
        height = _elem$getBoundingClie.height;
      var errorLabelRect = errorLabel.getBoundingClientRect();
      var pos = position || ((_a = this.globalConfig.tooltip) == null ? void 0 : _a.position);
      switch (pos) {
        case "left":
          {
            errorLabel.style.top = "".concat(top + height / 2 - errorLabelRect.height / 2, "px");
            errorLabel.style.left = "".concat(left - errorLabelRect.width - TOOLTIP_ARROW_HEIGHT, "px");
            break;
          }
        case "top":
          {
            errorLabel.style.top = "".concat(top - errorLabelRect.height - TOOLTIP_ARROW_HEIGHT, "px");
            errorLabel.style.left = "".concat(left + width / 2 - errorLabelRect.width / 2, "px");
            break;
          }
        case "right":
          {
            errorLabel.style.top = "".concat(top + height / 2 - errorLabelRect.height / 2, "px");
            errorLabel.style.left = "".concat(left + width + TOOLTIP_ARROW_HEIGHT, "px");
            break;
          }
        case "bottom":
          {
            errorLabel.style.top = "".concat(top + height + TOOLTIP_ARROW_HEIGHT, "px");
            errorLabel.style.left = "".concat(left + width / 2 - errorLabelRect.width / 2, "px");
            break;
          }
      }
      errorLabel.dataset.direction = pos;
      var refresh = function refresh() {
        _this14.renderTooltip(elem, errorLabel, position);
      };
      return {
        refresh: refresh
      };
    }
  }, {
    key: "createErrorLabelElem",
    value: function createErrorLabelElem(key, errorMessage, config) {
      var _errorLabel$classList;
      var errorLabel = document.createElement("div");
      errorLabel.innerHTML = errorMessage;
      var customErrorLabelStyle = this.isTooltip() ? config == null ? void 0 : config.errorLabelStyle : (config == null ? void 0 : config.errorLabelStyle) || this.globalConfig.errorLabelStyle;
      Object.assign(errorLabel.style, customErrorLabelStyle);
      (_errorLabel$classList = errorLabel.classList).add.apply(_errorLabel$classList, _toConsumableArray(getClassList((config == null ? void 0 : config.errorLabelCssClass) || this.globalConfig.errorLabelCssClass)).concat(["just-validate-error-label"]));
      if (this.isTooltip()) {
        errorLabel.dataset.tooltip = "true";
      }
      if (this.globalConfig.testingMode) {
        errorLabel.dataset.testId = "error-label-".concat(key);
      }
      this.errorLabels[key] = errorLabel;
      return errorLabel;
    }
  }, {
    key: "createSuccessLabelElem",
    value: function createSuccessLabelElem(key, successMessage, config) {
      var _successLabel$classLi;
      if (successMessage === void 0) {
        return null;
      }
      var successLabel = document.createElement("div");
      successLabel.innerHTML = successMessage;
      var customSuccessLabelStyle = (config == null ? void 0 : config.successLabelStyle) || this.globalConfig.successLabelStyle;
      Object.assign(successLabel.style, customSuccessLabelStyle);
      (_successLabel$classLi = successLabel.classList).add.apply(_successLabel$classLi, _toConsumableArray(getClassList((config == null ? void 0 : config.successLabelCssClass) || this.globalConfig.successLabelCssClass)).concat(["just-validate-success-label"]));
      if (this.globalConfig.testingMode) {
        successLabel.dataset.testId = "success-label-".concat(key);
      }
      this.successLabels[key] = successLabel;
      return successLabel;
    }
  }, {
    key: "renderErrorsContainer",
    value: function renderErrorsContainer(label, errorsContainer) {
      var container = errorsContainer || this.globalConfig.errorsContainer;
      if (typeof container === "string") {
        var elem = this.form.querySelector(container);
        if (elem) {
          elem.appendChild(label);
          return true;
        } else {
          console.error("Error container with ".concat(container, " selector not found. Errors will be rendered as usual"));
        }
      }
      if (container instanceof Element) {
        container.appendChild(label);
        return true;
      }
      if (container !== void 0) {
        console.error("Error container not found. It should be a string or existing Element. Errors will be rendered as usual");
      }
      return false;
    }
  }, {
    key: "renderGroupLabel",
    value: function renderGroupLabel(elem, label, errorsContainer, isSuccess) {
      if (!isSuccess) {
        var renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      elem.appendChild(label);
    }
  }, {
    key: "renderFieldLabel",
    value: function renderFieldLabel(elem, label, errorsContainer, isSuccess) {
      var _a, _b, _c, _d, _e, _f, _g;
      if (!isSuccess) {
        var renderedInErrorsContainer = this.renderErrorsContainer(label, errorsContainer);
        if (renderedInErrorsContainer) {
          return;
        }
      }
      if (elem.type === "checkbox" || elem.type === "radio") {
        var labelElem = document.querySelector("label[for=\"".concat(elem.getAttribute("id"), "\"]"));
        if (((_b = (_a = elem.parentElement) == null ? void 0 : _a.tagName) == null ? void 0 : _b.toLowerCase()) === "label") {
          (_d = (_c = elem.parentElement) == null ? void 0 : _c.parentElement) == null ? void 0 : _d.appendChild(label);
        } else if (labelElem) {
          (_e = labelElem.parentElement) == null ? void 0 : _e.appendChild(label);
        } else {
          (_f = elem.parentElement) == null ? void 0 : _f.appendChild(label);
        }
      } else {
        (_g = elem.parentElement) == null ? void 0 : _g.appendChild(label);
      }
    }
  }, {
    key: "showLabels",
    value: function showLabels(fields, isError) {
      var _this15 = this;
      Object.keys(fields).forEach(function (fieldName, i) {
        var error = fields[fieldName];
        var key = _this15.getKeyByFieldSelector(fieldName);
        if (!key || !_this15.fields[key]) {
          console.error("Field not found. Check the field selector.");
          return;
        }
        var field = _this15.fields[key];
        field.isValid = !isError;
        _this15.clearFieldStyle(key);
        _this15.clearFieldLabel(key);
        _this15.renderFieldError(key, false, error);
        if (i === 0 && _this15.globalConfig.focusInvalidField) {
          setTimeout(function () {
            return field.elem.focus();
          }, 0);
        }
      });
    }
  }, {
    key: "showErrors",
    value: function showErrors(fields) {
      if (_typeof(fields) !== "object") {
        throw Error("[showErrors]: Errors should be an object with key: value format");
      }
      this.showLabels(fields, true);
    }
  }, {
    key: "showSuccessLabels",
    value: function showSuccessLabels(fields) {
      if (_typeof(fields) !== "object") {
        throw Error("[showSuccessLabels]: Labels should be an object with key: value format");
      }
      this.showLabels(fields, false);
    }
  }, {
    key: "renderFieldError",
    value: function renderFieldError(key) {
      var _field$elem$classList3;
      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var message = arguments.length > 2 ? arguments[2] : undefined;
      var _a, _b, _c, _d, _e, _f;
      var field = this.fields[key];
      if (field.isValid === false) {
        this.isValid = false;
      }
      if (field.isValid === void 0 || !forced && !this.isSubmitted && !field.touched && message === void 0) {
        return;
      }
      if (field.isValid) {
        if (!field.asyncCheckPending) {
          var _field$elem$classList2;
          var successLabel = this.createSuccessLabelElem(key, message !== void 0 ? message : field.successMessage, field.config);
          if (successLabel) {
            this.renderFieldLabel(field.elem, successLabel, (_a = field.config) == null ? void 0 : _a.errorsContainer, true);
          }
          (_field$elem$classList2 = field.elem.classList).add.apply(_field$elem$classList2, _toConsumableArray(getClassList(((_b = field.config) == null ? void 0 : _b.successFieldCssClass) || this.globalConfig.successFieldCssClass)));
        }
        return;
      }
      (_field$elem$classList3 = field.elem.classList).add.apply(_field$elem$classList3, _toConsumableArray(getClassList(((_c = field.config) == null ? void 0 : _c.errorFieldCssClass) || this.globalConfig.errorFieldCssClass)));
      var errorLabel = this.createErrorLabelElem(key, message !== void 0 ? message : field.errorMessage, field.config);
      this.renderFieldLabel(field.elem, errorLabel, (_d = field.config) == null ? void 0 : _d.errorsContainer);
      if (this.isTooltip()) {
        this.tooltips.push(this.renderTooltip(field.elem, errorLabel, (_f = (_e = field.config) == null ? void 0 : _e.tooltip) == null ? void 0 : _f.position));
      }
    }
  }, {
    key: "renderGroupError",
    value: function renderGroupError(key) {
      var _this16 = this;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var _a, _b, _c, _d;
      var group = this.groupFields[key];
      if (group.isValid === false) {
        this.isValid = false;
      }
      if (group.isValid === void 0 || !force && !this.isSubmitted && !group.touched) {
        return;
      }
      if (group.isValid) {
        group.elems.forEach(function (elem) {
          var _elem$classList3;
          var _a2, _b2;
          Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.successFieldStyle) || _this16.globalConfig.successFieldStyle);
          (_elem$classList3 = elem.classList).add.apply(_elem$classList3, _toConsumableArray(getClassList(((_b2 = group.config) == null ? void 0 : _b2.successFieldCssClass) || _this16.globalConfig.successFieldCssClass)));
        });
        var successLabel = this.createSuccessLabelElem(key, group.successMessage, group.config);
        if (successLabel) {
          this.renderGroupLabel(group.groupElem, successLabel, (_a = group.config) == null ? void 0 : _a.errorsContainer, true);
        }
        return;
      }
      this.isValid = false;
      group.elems.forEach(function (elem) {
        var _elem$classList4;
        var _a2, _b2;
        Object.assign(elem.style, ((_a2 = group.config) == null ? void 0 : _a2.errorFieldStyle) || _this16.globalConfig.errorFieldStyle);
        (_elem$classList4 = elem.classList).add.apply(_elem$classList4, _toConsumableArray(getClassList(((_b2 = group.config) == null ? void 0 : _b2.errorFieldCssClass) || _this16.globalConfig.errorFieldCssClass)));
      });
      var errorLabel = this.createErrorLabelElem(key, group.errorMessage, group.config);
      this.renderGroupLabel(group.groupElem, errorLabel, (_b = group.config) == null ? void 0 : _b.errorsContainer);
      if (this.isTooltip()) {
        this.tooltips.push(this.renderTooltip(group.groupElem, errorLabel, (_d = (_c = group.config) == null ? void 0 : _c.tooltip) == null ? void 0 : _d.position));
      }
    }
  }, {
    key: "renderErrors",
    value: function renderErrors() {
      var forceRevalidation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.isSubmitted && !forceRevalidation && !this.globalConfig.validateBeforeSubmitting) {
        return;
      }
      this.clearErrors();
      this.isValid = true;
      for (var key in this.groupFields) {
        this.renderGroupError(key);
      }
      for (var _key2 in this.fields) {
        this.renderFieldError(_key2);
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      var _this17 = this;
      this.eventListeners.forEach(function (event) {
        _this17.removeListener(event.type, event.elem, event.func);
      });
      Object.keys(this.customStyleTags).forEach(function (key) {
        _this17.customStyleTags[key].remove();
      });
      this.clearErrors();
      if (this.globalConfig.lockForm) {
        this.unlockForm();
      }
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var _this18 = this;
      this.destroy();
      if (!this.form) {
        console.error("Cannot initialize the library! Form is not defined");
      } else {
        this.initialize(this.form, this.globalConfig);
        Object.keys(this.fields).forEach(function (key) {
          var fieldSelector = _this18.getFieldSelectorByKey(key);
          if (fieldSelector) {
            _this18.addField(fieldSelector, _toConsumableArray(_this18.fields[key].rules), _this18.fields[key].config);
          }
        });
      }
    }
  }, {
    key: "setCurrentLocale",
    value: function setCurrentLocale(locale) {
      if (typeof locale !== "string" && locale !== void 0) {
        console.error("Current locale should be a string");
        return;
      }
      this.currentLocale = locale;
      if (this.isSubmitted) {
        this.validate();
      }
    }
  }, {
    key: "onSuccess",
    value: function onSuccess(callback) {
      this.onSuccessCallback = callback;
      return this;
    }
  }, {
    key: "onFail",
    value: function onFail(callback) {
      this.onFailCallback = callback;
      return this;
    }
  }, {
    key: "onValidate",
    value: function onValidate(callback) {
      this.onValidateCallback = callback;
      return this;
    }
  }]);
  return JustValidate;
}();


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_just-validate_dist_just-validate_es_js.js.map